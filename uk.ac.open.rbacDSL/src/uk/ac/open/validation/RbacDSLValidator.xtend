/*
 * generated by Xtext
 */
package uk.ac.open.validation

import org.eclipse.xtext.validation.Check
import uk.ac.open.rbacDSL.Assignment
import uk.ac.open.rbacDSL.ForbiddenScenario
import uk.ac.open.rbacDSL.GrantedScenario
import uk.ac.open.rbacDSL.Permission
import uk.ac.open.rbacDSL.RbacDSLPackage
import uk.ac.open.rbacDSL.Role
import uk.ac.open.rbacDSL.User
import uk.ac.open.rbacDSL.UserRoleScenario
import uk.ac.open.rbacDSL.ObjectRoleScenario
import uk.ac.open.rbacDSL.ObjectScenario
import com.google.inject.Inject
import org.eclipse.xtext.resource.IResourceDescriptions
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider
import org.eclipse.xtext.resource.IContainer
import uk.ac.open.rbacDSL.RBACObject

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class RbacDSLValidator extends AbstractRbacDSLValidator {
	
	@Inject
	ResourceDescriptionsProvider resourceDescriptionsProvider;
	
	@Inject
	IContainer.Manager containerManager;
	
	public static val SSOD_VIOLATION = "uk.ac.open.rbacDSL.SSoD";
	public static val DSOD_VIOLATION = "uk.ac.open.rbacDSL.DSoD";
	
	/**
	 * Detects cycles in role hierarchies
	 */
//	@Check
//	def checkNoCyleInRoleHierarchies(Role role) {
//		if (role.parent.isEmpty())
//			return;
//		val visitedRoles = <Role>newHashSet();
//		visitedRoles.add(role);
//		var current = role.parent;
//		while (!current.isEmpty()) {
//			for (Role currentRole:current) {
//				if (visitedRoles.contains(currentRole)) {
//					error("cycle in role hierarchy of role '" + currentRole.name + "'", RbacDSLPackage::eINSTANCE.role_Parent);
//					return
//				}
//				visitedRoles.add(currentRole)
//			}
//		}
//	}
	
	@Check
	def checkNoSSoDViolations(User user) {
		var roles = user.roles
		for (Role role:roles) {
			if (!role.ssod.isEmpty()) {
				for (Role ssod:role.ssod) {
					if (roles.contains(ssod)) {
						error("SSoD violation for user '" 
							+ user.name + "'", 
							RbacDSLPackage::eINSTANCE.user_Roles,
							SSOD_VIOLATION, role.name, ssod.name);
					}
				}
			}
		}
	}
	
	@Check
	def checkNoDSoDViolationsGranted(GrantedScenario scenario) {
		var roles = scenario.roles
		for (Role role:roles) {
			if (!role.dsod.isEmpty()) {
				for (Role dsod:role.dsod) {
					if (roles.contains(dsod)) {
						error("DSoD violation for scenario '"
							+ scenario.name + "'",
							RbacDSLPackage::eINSTANCE.grantedScenario_Roles,
							DSOD_VIOLATION, role.name);
					}
				}
			}
		}
	}
	
	@Check
	def checkNoDSoDViolationsForbidden(ForbiddenScenario scenario) {
		var roles = scenario.roles
		for (Role role:roles) {
			if (!role.dsod.isEmpty()) {
				for (Role dsod:role.dsod) {
					if (roles.contains(dsod)) {
						error("DSoD violation for scenario '"
							+ scenario.name + "'",
							RbacDSLPackage::eINSTANCE.forbiddenScenario_Roles,
							DSOD_VIOLATION, role.name);
					}
				}
			}
		}
	}
	
	@Check
	def checkRoleActivation(GrantedScenario scenario) {
		var assigned = scenario.user.roles
		var activated = scenario.roles
		if (!assigned.containsAll(activated)) {
			error("Attempt to activate a role not assigned to the user for scenario '"
				+ scenario.name + "'", RbacDSLPackage::eINSTANCE.grantedScenario_Roles)
		}
	}
	
	@Check
	def checkRoleActivation(ForbiddenScenario scenario) {
		var assigned = scenario.user.roles
		var activated = scenario.roles
		if (!assigned.containsAll(activated)) {
			error("Attempt to activate a role not assigned to the user for scenario '"
				+ scenario.name + "'", RbacDSLPackage::eINSTANCE.forbiddenScenario_Roles)
		}
	}
	
	@Check
	def checkGrantedScenario(GrantedScenario scenario) {
		// first we build a list of the actions required for each object
		var requiredObjectActions = <ObjectAction>newArrayList()
		for (Assignment assignment:scenario.object) {
			for (Permission action:assignment.actions) {
				requiredObjectActions.add(new ObjectAction(assignment.object.name, action.name))
			}
		}
		
		// if there are no roles active, we fail (there must at least be one action required
		if (scenario.roles.isEmpty())
			error("Granted scenario violation on scenario '"
				+ scenario.name + "'", RbacDSLPackage::eINSTANCE.grantedScenario_Roles
			)
		// then we go through the available permissions to see if they're in the
		// above list
		for (Role role:scenario.roles) {
			for (Assignment assignment:role.assignments) {
				for (Permission action:assignment.actions) {
					var objAction = new ObjectAction(assignment.object.name, action.name)
					if (!requiredObjectActions.contains(objAction)) {
						error("Granted scenario violation on scenario '" 
							+ scenario.name + "'", RbacDSLPackage::eINSTANCE.grantedScenario_Object
						)
					}
				}
			}
		}
	}
	
	@Check
	def checkForbiddenScenario(ForbiddenScenario scenario) {
		// first we build a list of the actions required for each object
		var requiredObjectActions = <ObjectAction>newArrayList()
		for (Assignment assignment:scenario.object) {
			for (Permission action:assignment.actions) {
				requiredObjectActions.add(new ObjectAction(assignment.object.name, action.name))
			}
		}
		
		// then we go through the available permissions to see if they're in the
		// above list. At least one should be missing
		var success = false
		for (Role role:scenario.roles) {
			for (Assignment assignment:role.assignments) {
				for (Permission action:assignment.actions) {
					var objAction = new ObjectAction(assignment.object.name, action.name)
					if (!requiredObjectActions.contains(objAction)) {
						success = true // one permission missing, we're good
						return
					}
				}
			}
		}
		if (!success)
			error("Forbidden scenario violation on scenario '" 
				+ scenario.name + "'", RbacDSLPackage::eINSTANCE.forbiddenScenario_Object
			)
	}
	
	@Check
	def checkUserRoleScenario(UserRoleScenario scenario) {
	}
	
	@Check
	def checkAssignmentPermissions(Assignment assignment) {
		if (!assignment.object.permissions.containsAll(assignment.actions)) {
			error("Action not available for object '" + assignment.object.name
				+ "'", RbacDSLPackage::eINSTANCE.assignment_Object
			)
		}
	}
	
	@Check
	def checkObjectRoleScenario(ObjectRoleScenario scenario) {
		var oalist = new ObjectsActionsList(scenario.role)
		var assignments = scenario.assignment
		for (Assignment assignment:assignments) {
			var actions = newArrayList()
			for (Permission permission:assignment.actions) {
				actions.add(permission.name)
			}
			if (!oalist.hasAllActions(assignment.object.name, actions)) {
				error("Object-Role Scenario violation for scenario '" 
					+ scenario.name + "'", RbacDSLPackage::eINSTANCE.objectRoleScenario_Role
				)
			}
		}
	}
	
	@Check
	def checkObjectScenario(ObjectScenario scenario) {
		
	}
}
